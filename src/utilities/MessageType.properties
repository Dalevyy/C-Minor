#################################  List of C Minor Errors and Suggestions #################################

#  SYNTAX ERRORS
SYNTAX_ERROR_100 = Multi-line comment never terminates.
SYNTAX_ERROR_101 = An input statement can not be contained in an output statement.

#  SCOPE ERRORS
SCOPE_ERROR_300 = Local variable identifier '<arg0>' has already been declared in this scope.
SCOPE_ERROR_301 = Local variable '<arg0>' can not be initialized to itself.
SCOPE_ERROR_302 = Global variable identifier '<arg0>' has already been declared in this scope.
SCOPE_ERROR_303 = Global variable '<arg0>' can not be initialized to itself.
SCOPE_ERROR_304 = Parameter identifier '<arg0>' has been declared previously.
SCOPE_ERROR_305 = Enum identifier '<arg0>' has already been declared in this scope.
SCOPE_ERROR_306 = Enum constant identifier '<arg0>' has already been declared in this scope.
SCOPE_ERROR_307 = '<arg0>' has not been declared in the current scope.
SCOPE_ERROR_308 = Class '<arg0>' does not exist and can not be instantiated. 
SCOPE_ERROR_309 = Field '<arg0>' was not declared in class '<arg1>'.
SCOPE_ERROR_310 = Field '<arg0>' was already assigned an initial value.
SCOPE_ERROR_311 = Function identifier '<arg0>' has been declared previously.
SCOPE_ERROR_312 = Function '<arg0>' has already been declared with the given parameter types.
SCOPE_ERROR_313 = Method identifier '<arg0>' has been declared previously.
SCOPE_ERROR_314 = Method '<arg0>' has already been declared with the given parameter types.
SCOPE_ERROR_315 = Field identifier '<arg0>' has already been declared in this scope.
SCOPE_ERROR_316 = Class identifier '<arg0>' has been declared previously.
SCOPE_ERROR_317 = Class '<arg0>' can not inherit itself.
SCOPE_ERROR_318 = Field '<arg0>' was already declared in the base class.
SCOPE_ERROR_319 = Function '<arg0>' can not be invoked since it has not been declared.
SCOPE_ERROR_320 = Object '<arg0>' was not declared anywhere in the program.
SCOPE_ERROR_321 = Method '<arg0>' can not be invoked since it has not been declared.
SCOPE_ERROR_322 = Class '<arg0>' does not exist, so it can not be inherited.
SCOPE_ERROR_323 = A 'break' statement can only be written inside a loop.
SCOPE_ERROR_324 = A 'continue' statement can only be written inside a loop.
SCOPE_ERROR_325 = '<arg0>' is not a valid name for the left-hand side of an assignment statement.
SCOPE_ERROR_326 = '<arg0>' represents a type, and it can not be used as a name expression.
SCOPE_ERROR_327 = An input statement can only contain name expressions.
SCOPE_ERROR_328 = Class '<arg0>' was not declared anywhere in the program.
SCOPE_ERROR_329 = '<arg0>' does not represent a valid class name.
SCOPE_ERROR_330 = Invalid field expression written.
SCOPE_ERROR_331 = Field '<arg0>' can not be initialized to itself.
SCOPE_ERROR_332 = The LHS of a retype statement has to be a name, field, or array expression.
SCOPE_ERROR_333 = Method '<arg0>' must be marked overridden since it redefines the same method from class '<arg1>'.     
SCOPE_ERROR_334 = Method '<arg0>' does not override any parent class method.
SCOPE_ERROR_335 = The 'parent' keyword can only be used inside of classes.
SCOPE_ERROR_336 = The 'parent' keyword can not be used in a class that doesn't inherit from a parent class.
SCOPE_ERROR_337 = The 'parent' keyword can only appear at the start of a field expression.
SCOPE_ERROR_338 = Class '<arg0>' does not overload the '<arg1>' operator.

#  TYPE ERRORS
TYPE_ERROR_400 = Local variable '<arg0>' was declared with type <arg1>, but '<arg0>' was initialized to a value of type <arg2>.
TYPE_ERROR_401 = Global variable '<arg0>' was declared with type <arg1>, but '<arg0>' was intialized to a value of type <arg2>. 
TYPE_ERROR_402 = Constant variable '<arg0>' was declared with type <arg1>, but '<arg0>' was intialized to a value of type <arg2>. 
TYPE_ERROR_403 = Variable '<arg0>' was declared with type <arg1>, but '<arg0>' was assigned a value of type <arg2>.
TYPE_ERROR_404 = The assignment operation '<arg0>' can not be used with a variable of type <arg1>.
TYPE_ERROR_405 = The binary operation '<arg0>' has a left-hand side type of <arg1> and a right-hand side type of <arg2>.
TYPE_ERROR_406 = The binary operation '<arg0>' evaluates to type <arg1> which is not supported.
TYPE_ERROR_407 = The binary operation '<arg0>' has a left-hand side type of <arg1> which is not supported.
TYPE_ERROR_408 = The unary operation '<arg0>' evaluates to type <arg1> which is not supported.
TYPE_ERROR_409 = The expression above can not be typecasted into an expression of type <arg0>.
TYPE_ERROR_410 = The if statement's conditional expression evaluates to type <arg0>.
TYPE_ERROR_411 = The while loop's conditional expression evaluates to type <arg0>.
TYPE_ERROR_412 = The do while loop's conditional expression evaluates to type <arg0>.
TYPE_ERROR_413 = The for loop's control variable '<arg0>' was declared with type <arg1> which is not supported.
TYPE_ERROR_414 = The for loop's starting value has type <arg0> and the ending value has type <arg1>.
TYPE_ERROR_415 = The for loop's control variable '<arg0>' has type <arg1>, but the iteration expression has type <arg2>.
TYPE_ERROR_416 = The choice statement's value evaluates to type <arg0> which is not supported. 
TYPE_ERROR_417 = The case statement label evaluates to type <arg0>, but the choice statement's value evaluates to type <arg1>.
TYPE_ERROR_418 = A case statement does not support a range of String labels.
TYPE_ERROR_419 = The case statement's labels do not represent a valid range.
TYPE_ERROR_420 = Field variable '<arg0>' was declared with type <arg1>, but '<arg0>' was initialized to a value of type <arg2>.
TYPE_ERROR_421 = The type <arg0> does not represent a valid return type for the function '<arg1>'
TYPE_ERROR_422 = The function '<arg0>' does not return a value of type <arg1>.
TYPE_ERROR_423 = The type <arg0> does not represent a valid return type for the method '<arg1>' declared in class '<arg2>'.
TYPE_ERROR_424 = The method '<arg0>' declared in class '<arg1>' does not return a value of type <arg2>.
TYPE_ERROR_425 = The function '<arg0>' returns a value of type <arg1>, but '<arg0>' has a return type of Void.
TYPE_ERROR_426 = The method '<arg0>' declared in class '<arg1>' returns a value of type <arg2>, but '<arg0>' has a return type of Void.
TYPE_ERROR_427 = The function '<arg0>' returns a value of type <arg1>, but '<arg0>' has a return type of <arg2>.
TYPE_ERROR_428 = The method '<arg0>' declared in class '<arg1>' returns a value of type <arg2>, but '<arg0>' has a return type of <arg3>.
TYPE_ERROR_429 = The function '<arg0>' can not be invoked since there is not a valid overload for '<arg0>' with no arguments.
TYPE_ERROR_430 = The function '<arg0>' can not be invoked since there is not a valid overload for '<arg0>' with the argument type <arg1>.
TYPE_ERROR_431 = The function '<arg0>' can not be invoked since there is not a valid overload for '<arg0>' with the argument types <arg1>.
TYPE_ERROR_432 = The method '<arg0>' declared in class '<arg1>' can not be invoked since there is not a valid overload for '<arg0>' with no arguments.
TYPE_ERROR_433 = The method '<arg0>' declared in class '<arg1>' can not be invoked since there is not a valid overload for '<arg0>' with the argument type <arg2>.
TYPE_ERROR_434 = The method '<arg0>' declared in class '<arg1>' can not be invoked since there is not a valid overload for '<arg0>' with the argument types <arg2>.
TYPE_ERROR_435 = The target '<arg0>' has an invalid type of '<arg1>'.
TYPE_ERROR_436 = The enum '<arg0>' can not represent values with a type of <arg1>.
TYPE_ERROR_437 = The enum '<arg0>' does not have every constant initialized to a value.
TYPE_ERROR_438 = The constant '<arg0>' declared in enum '<arg1>' has type <arg2>, but '<arg1>' represents values of type <arg3>.
TYPE_ERROR_439 = The main function for the program has a return type of <arg0>, but main should have a return type of Void.
TYPE_ERROR_440 = The input expression '<arg0>' has a type of <arg1> which is not supported.
TYPE_ERROR_441 = Variable '<arg0>' has a type <arg1> which is not supported by retype statements.
TYPE_ERROR_442 = Object '<arg0>' can not be retyped into an object of type <arg1>.

# TYPE SUGGESTIONS
TYPE_SUGGEST_1400 = A variable declared with type <arg0> must be initialized to a value of type <arg0>.
TYPE_SUGGEST_1401 = A variable declared with type <arg0> can only be assigned values of type <arg0>.
TYPE_SUGGEST_1402 = The assignment operation '+=' is only supported for variables of type Int, Real, and String.
TYPE_SUGGEST_1403 = The assignment operation '<arg0>' is only supported for variables of type Int and Real.
TYPE_SUGGEST_1404 = The binary operation '<arg0>' must have both the left-hand side and right-hand side be the same type. 
TYPE_SUGGEST_1405 = The binary operation '<arg0>' is only supported for types Int, Char, and Real.
TYPE_SUGGEST_1406 = The binary operation '<arg0>' is only supported for type Int.
TYPE_SUGGEST_1407 = The binary operation '<arg0>' is only supported for types Int, Char, and Bool.
TYPE_SUGGEST_1408 = The binary operation '<arg0>' is only supported for type Bool.
TYPE_SUGGEST_1409 = The binary operation '<arg0>' must have a left-hand side type that represents an object.
TYPE_SUGGEST_1410 = The unary operation '<arg0>' is only supported for types Int, Char, and Bool.
TYPE_SUGGEST_1411 = The unary operation '<arg0>' is only supported for type Bool.
TYPE_SUGGEST_1412 = '<arg0>' evaluates to type Int which means the expression can only be typecasted into a Char or Real.
TYPE_SUGGEST_1413 = '<arg0>' evaluates to type Char which means the expression can only be typecasted into an Int or String.
TYPE_SUGGEST_1414 = '<arg0>' evaluates to type Real which means the expression can only be typecasted into an Int.
TYPE_SUGGEST_1415 = The following typecast is not supported by C Minor.
TYPE_SUGGEST_1416 = The conditional expression for an if statement has to evalaute to type Bool.
TYPE_SUGGEST_1417 = The conditional expression for a while loop has to evaluate to type Bool.
TYPE_SUGGEST_1418 = The conditional expression for a do while loop has to evaluate to type Bool.
TYPE_SUGGEST_1419 = A for loop control variable has to be declared with a type of Int, Char, or a user-defined Enum.
TYPE_SUGGEST_1420 = The for loop's starting and ending values must be the same type.
TYPE_SUGGEST_1421 = The type of the for loop control variable and the iteration expression must be the same.
TYPE_SUGGEST_1422 = A choice statement can only choose from a value of type Int, Char, or String.
TYPE_SUGGEST_1423 = The label for a case statement must match the type of the choice statement's value.
TYPE_SUGGEST_1424 = A case statement can only have a single label representing a String constant.
TYPE_SUGGEST_1425 = The case statement's right label must have a greater value than the left label when specifying a range.
TYPE_SUGGEST_1426 = <arg0> must be defined as a type in order to be used as a return type.
TYPE_SUGGEST_1427 = A function must return a value based on its declared return type.
TYPE_SUGGEST_1428 = A method must return a value based on its declared return type.
TYPE_SUGGEST_1429 = A function with a Void return type can not return any value.
TYPE_SUGGEST_1430 = A method with a Void return type can not return any value.
TYPE_SUGGEST_1431 = The function '<arg0>' must be overloaded as '<arg1>' in order to be invoked.
TYPE_SUGGEST_1432 = The method '<arg0>' declared in class '<arg1>' must be overloaded as '<arg2>' in order to be invoked.
TYPE_SUGGEST_1433 = The target must represent an object previously declared in the program.
TYPE_SUGGEST_1434 = Enums can only represent values of type Int (by default) or Char (if specified by the user).
TYPE_SUGGEST_1435 = All constants in an enum must be initialized to a value if at least one constant was initialized.
TYPE_SUGGEST_1436 = The value initialized to an enum constant must match the type the enum is representing.
TYPE_SUGGEST_1437 = An input statement can only read values representing an Int, Char, Bool, Real, or String.
TYPE_SUGGEST_1438 = A retype statement can only retype variables representing objects.
TYPE_SUGGEST_1439 = Object '<arg0>' can only be retyped to a type found in its class hierarchy.


#TYPE_ERROR_430 = Array index expression is of type '<arg0>', but it must have type 'Int'.
#TYPE_ERROR_434 = '<arg0>' does not represent a valid array type and can not be dereferenced.
#TYPE_ERROR_435 = The dimensions for an array literal must be specified with a constant 'Int' value.
#TYPE_ERROR_436 = An array literal can only have dimensions with type 'Int' and not type '<arg0>'.
#TYPE_ERROR_442 = The size of an n-Dimensional array must be specified.
#TYPE_ERROR_443 = A 1D array can not have more than one specified dimensions.
#TYPE_ERROR_444 = The number of array arguments does not match the size of the given array dimension.
#TYPE_ERROR_445 = The array has a base type of '<arg0>', but a value of type '<arg1>' was given as an initial value.
#TYPE_ERROR_446 = Innermost array literal dimension must match the outermost array literal dimension.
#TYPE_ERROR_447 = Argument must be an array literal for a multidimensional array.
#TYPE_ERROR_448 = '<arg0>' is an array with <arg1> dimensions, but the array index has <arg2> indices.
#TYPE_ERROR_450 = An array literal can only be assigned to a variable declared as an array.
#TYPE_ERROR_451 = A call to 'length' can only contain one argument.
#TYPE_ERROR_452 = A call to 'length' needs an argument of type array or list.

#TYPE_ERROR_455 = Argument must be a list literal for a multidimensional list.
#TYPE_ERROR_456 = The list has a base type of '<arg0>', but a value of type '<arg1>' was given as an initial value.
#TYPE_ERROR_457 = Function '<arg0>' only takes in <arg1> arguments, but <arg2> arguments were given.
#TYPE_ERROR_458 = The first argument for function '<arg0>' must be a variable name of type `List`.
#TYPE_ERROR_459 = The second argument for function '<arg0>' must match the base type of the list.
#TYPE_ERROR_460 = The second argument for function 'insert' must be an 'Int' position.
#TYPE_ERROR_461 = The third argument for function 'insert' must match the base type of the list.

#  MOD ERRORS
MOD_ERROR_500 = Class '<arg0>' can not inherit from class '<arg1>'.
MOD_ERROR_501 = Concrete class '<arg0>' does not implement all methods declared \
                in the abstract class '<arg1>'
MOD_ERROR_502 = A recursive function call can not be invoked on the function '<arg0>'.
MOD_ERROR_503 = A recursive method call can not be invoked on the method '<arg0>'.
MOD_ERROR_504 = Object '<arg0>' is trying to invoke the non-public method '<arg1>'.
MOD_ERROR_505 = Reassignment is not allowed for the constant variable '<arg0>'.
MOD_ERROR_506 = Object '<arg0>' can not be instantiated from the abstract class '<arg0>'.
MOD_ERROR_507 = Object '<arg0>' is trying to access the non-public field '<arg1>'.
MOD_ERROR_508 = Reassignment is not allowed for the enumerated constant '<arg0>'.

# RUNTIME ERRORS
RUNTIME_ERROR_600 = The number of input arguments does not match the expected number of input values.
RUNTIME_ERROR_601 = Unexpected input given! Input variable has type '<arg0>', but input value does not have the same type.
RUNTIME_ERROR_602 = Array index is trying to access memory not associated with the array.
RUNTIME_ERROR_603 = An array index must start at 1, not 0.
RUNTIME_ERROR_604 = The method '<arg0>' can not be called since the object is of type '<arg1>' and not '<arg2>'
RUNTIME_ERROR_605 = '<arg0>' is a list of size '<arg1>', and '<arg2>' is not a valid insert position.
RUNTIME_ERROR_606 = The field '<arg0>' can not be accessed since the current object type is '<arg1>'.

# GENERAL SEMANTIC ERRORS
SEMANTIC_ERROR_700 = <arg0> variable '<arg1>' was not initialized to a value.
SEMANTIC_ERROR_701 = A unary operator overload can not have any arguments.
SEMANTIC_ERROR_702 = A binary operator overload must have exactly one argument.

# SEMANTIC SUGGESTIONS
SEMANTIC_SUGGEST_1700 = A variable must be initialized to a default value or marked as `uninit` in order to be used.

# SCOPE SUGGESTIONS

SCOPE_SUGGEST_1300 = 'arg<0>' declared below.
SCOPE_SUGGEST_1301 = Redeclaration of 'arg<0>' in the same scope is not allowed.
SCOPE_SUGGEST_1302 = Only previously declared variables or field expressions are allowed for assignments.


# MOD SUGGESTIONS
MOD_SUGGEST_1500 = Classes declared with 'final' keyword can not be inherited.
MOD_SUGGEST_1501 = A concrete class must define all methods inherited from an abstract class.
MOD_SUGGEST_1502 = Recursive invocations can only be made on functions that allow recursion.
MOD_SUGGEST_1503 = Recursive invocations can only be made on methods that allow recursion.
MOD_SUGGEST_1504 = Only public methods are accessible outside a class.
MOD_SUGGEST_1505 = Constant variables can only be assigned once during declaration.
MOD_SUGGEST_1506 = Objects may only be instantiated from concrete classes.
MOD_SUGGEST_1507 = Only public fields are accessible outside a class.
