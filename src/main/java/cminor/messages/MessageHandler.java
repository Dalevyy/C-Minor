package cminor.messages;

import cminor.messages.errors.ErrorBuilder;
import cminor.messages.errors.mod.ModErrorBuilder;
import cminor.messages.errors.runtime.RuntimeErrorBuilder;
import cminor.messages.errors.scope.RedeclarationError;
import cminor.messages.errors.scope.ScopeErrorBuilder;
import cminor.messages.errors.semantic.SemanticErrorBuilder;
import cminor.messages.errors.setting.SettingErrorBuilder;
import cminor.messages.errors.syntax.SyntaxErrorBuilder;
import cminor.messages.errors.type.TypeErrorBuilder;
import cminor.messages.warnings.WarningBuilder;
import cminor.utilities.Vector;

/**
 * A class designed to handle all messages generated by the compiler.
 * <p>
 *     This class primarily serves as a way for us to easily generate and store messages
 *     during the compilation process. There are a series of helper methods that will generate
 *     an appropriate {@link ErrorBuilder} when we are inside a {@link cminor.utilities.Visitor}, and
 *     every message that is generated will be stored within this class. This allows us to print
 *     multiple messages to the user if there are multiple issues found with their program.
 * </p>
 * @author Daniel levy
 */
public class MessageHandler {

    /**
     * The current file we will be generating messages for.
     */
    private final String fileName;

    /**
     * List of messages that the current {@link MessageHandler} has generated.
     */
    private final Vector<Message> messages;

    /**
     * Flag that will be set by {@link cminor.interpreter.VM} when executing the interpreter.
     */
    private static boolean inInterpretationMode = false;

    /**
     * Default constructor for {@link MessageHandler}. This will be called in interpretation mode.
     */
    public MessageHandler() { this(""); }

    /**
     * Main constructor for {@link MessageHandler}.
     * @param fileName The file that this handler will create messages for.
     */
    public MessageHandler(String fileName) {
        this.fileName = fileName;
        this.messages = new Vector<>();
    }

    /**
     * Stores a message into {@link #messages} or throws an exception if in interpretation mode.
     * <p>
     *     If we are in interpretation mode, then we need to have the VM handle the error immediately
     *     since we will not be able to continue interpretation.
     * </p>
     * @param msg {@link Message} that will be handled by the {@link MessageHandler}.
     */
    public void storeMessage(Message msg) {
        msg.createMessage(fileName);

        if(inInterpretationMode && msg.isError()) {
            // Throw special exception if we are redeclaring a node.
            if(msg.asError().isScopeError() && msg.asError().asScopeError().isRedeclarationError())
                throw new RedeclarationError(msg.asError().asScopeError());

            throw new CompilationMessage(msg);
        }
        else
            messages.add(msg);

        System.out.println(msg.msg); // Just print out the warning for now... maybe do a more elegant solution later?
    }

    /**
     * Sets every {@link MessageHandler} object to work under interpretation mode.
     */
    public static void setInterpretationMode() { inInterpretationMode = true; }

    public void printMessages() {
        if(messages.isEmpty())
            return;

        for(Message m : messages)
            System.out.println(m.msg);
        System.exit(0);
    }

    /**
     * Generate an {@link ErrorBuilder} based on a passed {@link Error} type.
     * <p>
     *     This is a solution I created to make it easier to instantiate {@link ErrorBuilder} based on the
     *     type of error we need to generate. I'm not sure if it's the most ideal solution, but it seems to
     *     be getting the job done.
     * </p>
     * @param errorType The {@link cminor.messages.errors.Error} class we wish to create a builder for.
     * @return {@link ErrorBuilder}
     */
    public ErrorBuilder createErrorBuilder(Class<?> errorType) {
        return switch (errorType.getSimpleName()) {
            case "ModError" -> new ModErrorBuilder(this);
            case "RuntimeError" -> new RuntimeErrorBuilder(this);
            case "ScopeError" -> new ScopeErrorBuilder(this);
            case "SettingError" -> new SettingErrorBuilder(this);
            case "SemanticError" -> new SemanticErrorBuilder(this);
            case "SyntaxError" -> new SyntaxErrorBuilder(this);
            case "TypeError" -> new TypeErrorBuilder(this);
            default -> throw new RuntimeException("The passed type does not represent a valid Error type.");
        };
    }

    /**
     * Generates a {@link WarningBuilder}.
     * @return {@link WarningBuilder}
     */
    public WarningBuilder createWarningBuilder() { return new WarningBuilder(this); }
}
