package cminor.ast.classbody;

import cminor.ast.AST;
import cminor.ast.statements.AssignStmt;
import cminor.ast.topleveldecls.ClassDecl;
import cminor.token.Token;
import cminor.utilities.Vector;
import cminor.utilities.Visitor;

/**
 * A {@link ClassNode} representing a constructor for a {@link ClassDecl}.
 * <p>
 *     In C Minor, users do not declare class constructors. Instead, it is the job of
 *     the compiler to generate a single constructor that will initialize objects with
 *     default field values if the user does not initialize the fields themselves. This
 *     node is generated by the {@link micropasses.ConstructorGeneration} micropass.
 * </p>
 * @author Daniel Levy
 */
public class InitDecl extends ClassNode {

    /**
     * {@link Vector} of {@link AssignStmt} that will initialize an object's fields.
     */
    private Vector<AssignStmt> initStmts;

    /**
     * Default constructor for {@link InitDecl}.
     */
    public InitDecl() { this(new Vector<>()); }

    /**
     * Main constructor for {@link InitDecl}.
     * @param initStmts {@link Vector} of {@link AssignStmt} that will be stored into {@link #initStmts}.
     */
    public InitDecl(Vector<AssignStmt> initStmts) {
        super(new Token());

        this.initStmts = initStmts;

        addChildNode(initStmts);
    }

    /**
     * Getter method that returns {@link #initStmts}.
     * @return {@link Vector} of {@link AssignStmt} representing how an object will be initialized.
     */
    public Vector<AssignStmt> getInitStmts() { return this.initStmts; }

    /**
     * {@inheritDoc}
     */
    public ClassDecl getClassDecl() { return parent.asTopLevelDecl().asClassDecl(); }

    /**
     * {@inheritDoc}
     */
    public boolean isInitDecl() { return true; }

    /**
     * {@inheritDoc}
     */
    public InitDecl asInitDecl() { return this; }

    /**
     * {@inheritDoc}
     */
    @Override
    public void update(int pos, AST node) {
        initStmts.remove(pos);
        initStmts.add(pos, node.asStatement().asAssignStmt());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AST deepCopy() {
        Vector<AssignStmt> inits = new Vector<>();

        for(AssignStmt as : initStmts)
            inits.add(as.deepCopy().asStatement().asAssignStmt());

        return new InitDeclBuilder()
                   .setMetaData(this)
                   .setInits(inits)
                   .create();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void visit(Visitor v) { v.visitInitDecl(this); }

    /**
     * Internal class that builds an {@link InitDecl} object.
     */
    public static class InitDeclBuilder extends NodeBuilder {

        /**
         * {@link InitDecl} object we are building.
         */
        private final InitDecl id = new InitDecl();

        /**
         * @see ast.AST.NodeBuilder#setMetaData(AST, AST)
         * @return Current instance of {@link InitDeclBuilder}.
         */
        public InitDeclBuilder setMetaData(AST node) {
            super.setMetaData(id, node);
            return this;
        }

        /**
         * Sets the init declaration's {@link #initStmts}.
         * @param inits {@link Vector} of {@link AssignStmt} that contains initialization statements for an object.
         * @return Current instance of {@link InitDeclBuilder}.
         */
        public InitDeclBuilder setInits(Vector<AssignStmt> inits) {
            id.initStmts = inits;
            return this;
        }

        /**
         * Creates an {@link InitDecl} object.
         * @return {@link InitDecl}
         */
        public InitDecl create() {
            id.addChildNode(id.initStmts);
            return id;
        }
    }
}
